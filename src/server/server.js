import Http from 'http';
import Path from 'path';
import Helmet from 'helmet';
import Crypto from 'crypto';
import Express from 'express';
import SocketIO from 'socket.io';
import Compression from 'compression';

import Room from './objects/Room';
import Deck from './objects/Deck';
import Player from './objects/Player';
import BotPlayer from './objects/BotPlayer';

// Tablica do ≈õledzenia aktywnych pokoj√≥w.
let rooms = [];

// Konfiguracja serwera.
const app = Express();
const server = Http.Server(app);
const io = SocketIO(server);
const port = process.env.PORT || 3000;

// Odpalenie Helmet i Compression dla bezpiecze≈Ñstwa i wydajno≈õci
app.use(Helmet());
app.use(Compression());

// Dodanie middleware do obs≈Çugi plik√≥w statycznych (do serwowania plik√≥w statycznych).
app.use('/public', Express.static(Path.join(__dirname, '../public')));

// Request router.
app.get('/', function(request, response) {
  response.sendFile(Path.join(__dirname, '../public/index.html'));
})

// Uruchom serwer i zacznij nas≈Çuchiwaƒá po≈ÇƒÖcze≈Ñ.
server.listen(port, () => {
  console.log('\nüï∫ server init complete, listening for connections on port ' + port + ' üï∫\n');

  // Rozpocznij nas≈Çuchiwanie wydarze≈Ñ z klienta.
  setServerHandlers();
});

/**
 * Ustawienie obs≈Çugi wydarze≈Ñ serwera.
 */
function setServerHandlers() {
  io.on('connection', (socket) => {
    socket.on('new game', onNewGame);
    socket.on('join request', onJoinRequest);
    socket.on('new player', onNewPlayer);
    socket.on('add bot', (roomCode) => onAddBot(socket, roomCode)); // zmiana tutajj
    socket.on('player ready', onPlayerReady);
    socket.on('game start', onGameStart);
    socket.on('card played', function(card, wildcardSuit = false) {

      const player = rooms[socket.player.roomCode].players.find(p => p.id === socket.id);
      onCardPlayed.call(player, card, wildcardSuit);
    });
    socket.on('draw card', function() {
      const player = rooms[socket.player.roomCode].players.find(p => p.id === socket.id);
      onDrawCard.call(player);
    });
    socket.on('player message', onPlayerMessage);
    socket.on('player quit', onPlayerQuit);
    socket.on('disconnect', onDisconnect);
  });
}

/**
 * Obs≈Çuga tworzenia nowej gry.
 */
function onNewGame(roomCode) {
  // Je≈õli nie podano kodu pokoju, wygeneruj losowy.
  if (!roomCode) {
    Crypto.randomBytes(2, (err, buf) => {
      // Wygeneruj losowy kod pokoju.
      const roomCode = buf.toString('hex');

      // Dodaj pok√≥j do tablicy rooms.
      rooms[roomCode] = new Room(roomCode);

      // Po≈ÇƒÖcz u≈ºytkownika z pokojem.
      this.join(roomCode);

      // Wy≈õlij kod pokoju z powrotem do klienta.
      this.emit('new game', roomCode);

      this.roomCode = roomCode;
    });
  }
  else {
    const foundRoom = Object.keys(rooms).find(room => room === roomCode);

    if (foundRoom) {
      // Powiadom u≈ºytkownika, ≈ºe pok√≥j ju≈º istnieje.
      this.emit('room error', 'ROOM ALREADY EXISTS');
    }
    else {
      // Dodaj pok√≥j do tablicy rooms.
      rooms[roomCode] = new Room(roomCode);

      // Po≈ÇƒÖcz u≈ºytkownika z pokojem.
      this.join(roomCode);

      // Wy≈õlij kod pokoju z powrotem do klienta.
      this.emit('new game', roomCode);

      this.roomCode = roomCode;
    }
  }
}

/**
 * Obs≈Çuga dodawania bota do gry.
 */
function onAddBot(socket, roomCode) {
  if (rooms[roomCode]) {
    const botSocket = {
      emit: (event, data) => {
        io.to(roomCode).emit(event, data);
      },
      id: `bot-${Date.now()}`
    };

    const bot = new BotPlayer(botSocket.id, 'Bot', roomCode, [], botSocket);
    bot.ready = true;
    rooms[roomCode].players.push(bot);
    io.in(roomCode).emit('new player', bot);

    if (checkAllPlayersReady(roomCode)) {
      io.in(roomCode).emit('start countdown');
      rooms[roomCode].countdownStarted = true;

      for (let player of getPlayersInRoom(roomCode)) {
        player.textureMap = [];
      }
    }
  }
}

/**
 * Obs≈Çuga do≈ÇƒÖczenia do istniejƒÖcej gry.
 */
function onJoinRequest(roomCode) {
  // Sprawd≈∫, czy podany kod pokoju jest aktualnie w u≈ºyciu.
  const foundRoom = Object.keys(rooms).find(room => room === roomCode);

  // Je≈õli kod pokoju jest prawid≈Çowy i gra nie zosta≈Ça rozpoczƒôta, po≈ÇƒÖcz u≈ºytkownika.
  if (foundRoom) {
    const socketsInRoom = getSocketsInRoom(roomCode).length;

    // Je≈õli w pokoju jest mniej ni≈º 4 po≈ÇƒÖczenia, po≈ÇƒÖcz.
    if (socketsInRoom < 4) {
      if (rooms[foundRoom].gameStarted === false) {
        // Po≈ÇƒÖcz u≈ºytkownika z pokojem.
        this.join(roomCode);

        // Wy≈õlij kod pokoju z powrotem do klienta.
        this.emit('join game', roomCode);
      }
      else {
        // Powiadom u≈ºytkownika, ≈ºe gra w pokoju jest w toku.
        this.emit('room error', 'GAME IS IN PROGRESS');
      }
    }
    else {
      // Powiadom u≈ºytkownika, ≈ºe pok√≥j jest pe≈Çny.
      this.emit('room error', 'ROOM IS FULL');
    }
  }
  else {
    // Powiadom u≈ºytkownika, ≈ºe pok√≥j nie istnieje.
    this.emit('room error', 'GAME DOES NOT EXIST');
  }
}

/**
 * Powiadom innych, ≈ºe nowy gracz siƒô po≈ÇƒÖczy≈Ç.
 *
 * Wy≈õlij klientowi listƒô istniejƒÖcych graczy w pokoju.
 */
function onNewPlayer(playerObj, roomCode) {
  const player = new Player(this.id, playerObj.name, roomCode, playerObj.textureMap);
  this.player = player;

  // Zbuduj listƒô wszystkich obecnych graczy i wy≈õlij dane do klienta.
  this.emit('get players', getPlayersInRoom(roomCode));

  // Dodaj gracza do tablicy graczy w pokoju.
  rooms[roomCode].players.push(this.player);

  // Powiadom innych graczy o nowym graczu.
  this.broadcast.to(roomCode).emit('new player', this.player);
}

/**
 * Powiadom innych, ≈ºe gracz jest gotowy do gry.
 *
 * Je≈õli wszyscy gracze sƒÖ gotowi, losowo wybierz pierwszego gracza i powiadom wszystkich, ≈ºe gra siƒô rozpoczƒô≈Ça.
 */
function onPlayerReady() {
  const roomCode = this.player.roomCode;

  // Gracz jest gotowy do gry.
  this.player.ready = true;

  // Powiadom wszystkich, ≈ºe gracz jest gotowy.
  this.broadcast.to(roomCode).emit('show player ready', this.player);

  // Sprawd≈∫, czy wszyscy gracze sƒÖ gotowi.
  if (checkAllPlayersReady(roomCode)) {
    io.in(roomCode).emit('start countdown');

    rooms[roomCode].countdownStarted = true;

    // Wyczy≈õƒá mapƒô tekstur gracza, aby oczy≈õciƒá przesy≈Çane dane JSON.
    for (let player of getPlayersInRoom(roomCode)) {
      player.textureMap = [];
    }
  }
}

/**
 * Rozpocznij grƒô, gdy timer odliczania ka≈ºdego gracza siƒô zako≈Ñczy.
 */
function onGameStart() {
  const roomCode = this.player.roomCode;

  rooms[roomCode].startGameCounter++;

  if (rooms[roomCode].startGameCounter === rooms[roomCode].players.length) {
    rooms[roomCode].gameStarted = true;
    io.in(roomCode).emit('game started');
    rooms[roomCode].players = shufflePlayerOrder(roomCode);
    const firstPlayer = rooms[roomCode].players[0];
    io.in(roomCode).emit('show player turn', firstPlayer);
    rooms[roomCode].deck = new Deck();

    for (let i = 0; i <= 7; i++) {
      for (let player of rooms[roomCode].players) {
        dealCardsToPlayer(player);
      }
    }

    const firstCardInPlay = rooms[roomCode].deck.drawPile.shift();
    io.in(roomCode).emit('update card in play', firstCardInPlay);
    rooms[roomCode].deck.playPile.unshift(firstCardInPlay);
    io.in(roomCode).emit('show first card in play', firstCardInPlay);

    handleNextPlayerTurn(firstPlayer, roomCode);
  }
}

function handleNextPlayerTurn(player, roomCode) {
  if (player.isBot) {
    // Reset currentPlayerId to allow bot to take a new turn
    rooms[roomCode].currentPlayerId = null;

    setTimeout(() => {
      const move = player.decideMove({
        currentSuit: rooms[roomCode].cardInPlay.suit,
        currentValue: rooms[roomCode].cardInPlay.value,
      });

      if (!move) {
        onDrawCard.call(player);
      } else {
        if (move.card.value === 'a') {
          // Bot wybiera najlepszy kolor (suit) na podstawie kart w rƒôku
          const bestSuit = move.wildcardSuit;
          onCardPlayed.call(player, move.card, bestSuit);
        } else {
          onCardPlayed.call(player, move.card);
        }
      }

      // After the move, reset bot's state to allow for the next turn
      rooms[roomCode].currentPlayerId = player.id;
    }, 500); // Simulate thinking time
  } else {
    rooms[roomCode].currentPlayerId = player.id;
    io.in(roomCode).emit('show player turn', player);
    io.to(player.id).emit('turn start');
  }
}



/**
 * Powiadom graczy, ≈ºe ruch zosta≈Ç wykonany, przejd≈∫ do nastƒôpnego gracza.
 */
function onCardPlayed(card, wildcardSuit = false) {
  const roomCode = this.roomCode;
  const deck = rooms[roomCode].deck;

  // Zapobiegaj przetwarzaniu tej samej karty dwukrotnie, sprawdzajƒÖc, czy zosta≈Ça ju≈º zagrana
  if (this.lastPlayedCard && this.lastPlayedCard.name === card.name && this.lastPlayedCard.suit === card.suit) {
      console.log('Duplicate card play detected, ignoring:', card.name);
      return;
  }

  // Zapisz kartƒô jako ostatnio zagranƒÖ kartƒô
  this.lastPlayedCard = card;

  this.removeCardFromHand(card, deck);

  // Powiadom wszystkich klient√≥w, ile kart ma gracz.
  io.in(roomCode).emit('update hand count', this, this.hand.length);

  // Sprawd≈∫, czy rƒôka gracza jest pusta, je≈õli tak, obni≈º wynik i rozdaj wiƒôcej kart.
  if (this.checkHandEmpty()) {
    this.countdown--;

    // Sprawd≈∫, czy gra siƒô sko≈Ñczy≈Ça.
    if (this.countdown === 0) {
      // Powiadom graczy, ≈ºe gra siƒô zako≈Ñczy≈Ça i kto wygra≈Ç.
      io.in(roomCode).emit('game over', this);
      return; // Stop here.
    }

    io.in(roomCode).emit('update countdown score', this);

    dealCardsToPlayer(this, this.countdown);
  }

  // Je≈õli zosta≈Ça zagrana karta zmieniajƒÖca kolor, powiadom graczy, ≈ºe kolor siƒô zmieni≈Ç.
  if (wildcardSuit) {
    const wildcard = { value: false, suit: wildcardSuit };

    io.in(roomCode).emit('update card in play', wildcard);
    rooms[roomCode].cardInPlay = wildcard;
  } else {
    io.in(roomCode).emit('update card in play', card);
    rooms[roomCode].cardInPlay = card;
  }

  io.in(roomCode).emit('show card played', this, card);

  // Obs≈Çuga odwr√≥cenia kierunku (3+ graczy)
  if (rooms[roomCode].players.length > 2 && card.value === 'k') {
    rooms[roomCode].reverseDirection = !rooms[roomCode].reverseDirection;
    io.in(roomCode).emit('game message', 'YOU REVERSED THE DIRECTION OF PLAY');
    io.in(roomCode).emit(roomCode).emit('game message', `${this.name} REVERSED THE DIRECTION PLAY`);
  }

  if (card.value === '4') {
    const skippedPlayer = rooms[roomCode].getNextPlayer();
    io.in(roomCode).emit('game message', `YOU SKIPPED ${skippedPlayer.name}'S TURN`);
    io.to(skippedPlayer.id).emit('game message', `${this.name} SKIPPED YOUR TURN`);
    
    // Pobierz nastƒôpnego gracza (po pominiƒôtym) i przeka≈º turƒô
    const nextPlayer = rooms[roomCode].getNextPlayer();
    
    // Emituj informacje o turze i obs≈Çu≈º turƒô nastƒôpnego gracza
    io.in(roomCode).emit('show player turn', nextPlayer);
    io.to(nextPlayer.id).emit('turn start');
  
    // Obs≈Çuga tury bota, je≈õli nastƒôpny gracz jest botem
    return handleNextPlayerTurn(nextPlayer, roomCode);
  }
  
  const player = rooms[roomCode].getNextPlayer();

  if (card.name === 'k of spades') {
    let prevPlayer = rooms[roomCode].getPreviousPlayer();
    // Upewnij siƒô, ≈ºe poprzedni gracz nie jest tym, kt√≥ry zagra≈Ç kartƒô (dla 2 graczy)
    if (prevPlayer.id === this.id) {
      prevPlayer = rooms[roomCode].getNextPlayer();
    }

    io.to(prevPlayer.id).emit('game message', 'PICKUP 5 CARDS');
    dealCardsToPlayer(prevPlayer, 5);
  }

  if (card.name === 'k of hearts') {
    io.to(player.id).emit('game message', 'PICKUP 5 CARDS');
    dealCardsToPlayer(player, 5);
  }

  if (card.value === '2' || card.value === '3') {
    const cardsToDraw = (card.value === '2') ? 2 : 3;
    io.to(player.id).emit('game message', `PICKUP ${cardsToDraw} CARDS`);
    dealCardsToPlayer(player, cardsToDraw);
  }

  io.in(roomCode).emit('show player turn', player);
  io.to(player.id).emit('turn start');

  return handleNextPlayerTurn(player, roomCode);
}

/**
 * Gracz nie ma grywalnych kart, dobierz nowƒÖ kartƒô i przejd≈∫ dalej.
 */
function onDrawCard() {
  const roomCode = this.roomCode;

  dealCardsToPlayer(this);
  io.in(roomCode).emit('show card draw', this);

  const cardDealt = this.getLastCardInHand();
  const isPlayable = checkCardPlayable(cardDealt, rooms[roomCode].cardInPlay, this);

  if (isPlayable) {
    console.log(`${this.name} drew a playable card: ${cardDealt.name}`);
    const player = rooms[roomCode].getNextPlayer();
    io.to(this.id).emit('play drawn card', cardDealt);
    return handleNextPlayerTurn(player, roomCode);
  } else {
    console.log(`${this.name} drew a non-playable card, passing turn.`);
    const player = rooms[roomCode].getNextPlayer();
    io.in(roomCode).emit('show player turn', player);
    io.to(player.id).emit('turn start');
    return handleNextPlayerTurn(player, roomCode);
  }
}


/**
 * Gdy gracz wy≈õle wiadomo≈õƒá, wy≈õlij jƒÖ wszystkim.
 */
function onPlayerMessage(message) {
  const player = this.player;

  io.in(player.roomCode).emit('player message', message, player);
}

/**
 * Gdy gracz opuszcza grƒô, powiadom wszystkich innych w pokoju.
 */
function onPlayerQuit() {
  const player = this.player;

  this.broadcast.to(player.roomCode).emit('player quit', player);
}

/**
 * Obs≈Çuga roz≈ÇƒÖczenia u≈ºytkownika, powiadom innych, kto odszed≈Ç.
 */
function onDisconnect() {
  // Check to see if the socket has a player data object.
  if ('player' in this) {
    const roomCode = this.player.roomCode;
    const players = getPlayersInRoom(roomCode);

    // Sprawd≈∫, czy pok√≥j jest pusty.
    if (players.length === 0) {
      // Je≈õli pok√≥j jest pusty, usu≈Ñ go z mapy.
      delete rooms[roomCode];

      return; // Stop here.
    }
    else {
      // Oznacz wszystkich graczy jako niegotowych.
      for (let player of players) {
        player.ready = false;
      }

      // Powiedz wszystkim, ≈ºe gracz siƒô roz≈ÇƒÖczy≈Ç.
      io.in(roomCode).emit('player disconnect', this.player);

      // Je≈õli kto≈õ opu≈õci grƒô podczas odliczania do rozpoczƒôcia gry, zatrzymaj timer i
      // zresetuj zmienne zwiƒÖzane z odliczaniem.
      if (rooms[roomCode].countdownStarted) {
        rooms[roomCode].countdownStarted = false;
        rooms[roomCode].startGameCounter = 0;
      }

      if (rooms[roomCode].gameStarted && !rooms[roomCode].gameOver) {
        // Je≈õli w pokoju zosta≈Ç tylko jeden gracz i gra siƒô rozpoczƒô≈Ça,
        // gra siƒô ko≈Ñczy.
        if (rooms[roomCode].players.length === 2) {
          let winner;

          for (let player of rooms[roomCode].players) {
            if (player.id !== this.id) {
              winner = player
            }
          }

          // Powiadom gracza, ≈ºe gra siƒô zako≈Ñczy≈Ça i ≈ºe wygra≈Ç!
          io.in(roomCode).emit('game over', winner);

          return; // Stop here
        }

        // Zwr√≥ƒá karty z rƒôki gracza z powrotem do stosu, aby karty wr√≥ci≈Çy do obiegu
        const deck = rooms[roomCode].deck;

        for (let card of this.player.hand) {
          deck.addCardToPlayPile(card);
        }

        // Pobierz turƒô gracza, aby sprawdziƒá, czy gracz roz≈ÇƒÖczy≈Ç siƒô podczas swojej tury
        const playerTurn = rooms[roomCode].playerTurn;

        // Je≈õli gracz roz≈ÇƒÖczy≈Ç siƒô w swojej turze, przejd≈∫ do nastƒôpnego gracza w kolejno≈õci
        if (rooms[roomCode].players[playerTurn].id == this.id) {
          // Pobierz nastƒôpnego gracza do gry.
          const player = rooms[roomCode].getNextPlayer();

          // Powiadom wszystkich, kto teraz gra.
          io.in(roomCode).emit('show player turn', player);

          // Powiadom gracza, aby rozpoczƒÖ≈Ç turƒô.
          io.to(player.id).emit('turn start');
        }
      }

      // Usu≈Ñ gracza z tablicy graczy w pokoju.
      rooms[roomCode].removePlayerByID(this.id);
    }
  }
  else {
    // Dodatkowe sprawdzenie, by zobaczyƒá, czy socket roz≈ÇƒÖczy≈Ço siƒô bez
    // utworzenia obiektu gracza (krok doboru).
    if (this.roomCode) {
      // Je≈õli pok√≥j jest pusty po roz≈ÇƒÖczeniu socketa, usu≈Ñ pok√≥j.
      if (getSocketsInRoom(this.roomCode).length === 0) {
        delete rooms[this.roomCode];
      }
    }
  }
}

/**
 * Sprawd≈∫ i zwr√≥ƒá, czy wszyscy gracze sƒÖ gotowi do gry.
 */
function checkAllPlayersReady(roomCode) {
  const players = getPlayersInRoom(roomCode);

  let ready = true;

  // Kontynuuj tylko wtedy, gdy jest 2 lub wiƒôcej graczy.
  if (players.length >= 2) {
    // Sprawd≈∫, czy kt√≥ry≈õ z graczy nie jest gotowy.
    for (let player of players) {
      if (player.ready === false) {
        ready = false;
      }
    }
  }
  else {
    ready = false;
  }
  return ready;
}

/**
 * Przetasowanie kolejno≈õci graczy za pomocƒÖ algorytmu Fisher-Yates.
 */
function shufflePlayerOrder(roomCode) {
  const players = getPlayersInRoom(roomCode);

  for (let i = players.length - 1; i > 0; i--) {
    const randomIndex = Math.floor(Math.random() * (i + 1));
    const itemAtIndex = players[randomIndex];

    players[randomIndex] = players[i];
    players[i] = itemAtIndex;
  }

  return players;
}

/**
 * Zwraca wszystkie sockety aktualnie po≈ÇƒÖczone z pokojem.
 */
function getSocketsInRoom(roomCode) {
  const sockets = [];

  // Sprawd≈∫, czy kto≈õ w og√≥le jest w pokoju.
  if (io.sockets.adapter.rooms[roomCode] !== undefined) {
    // Iteruj po socketach pod≈ÇƒÖczonych do pokoju, zwr√≥ƒá wszystkich znalezionych graczy.
    Object.keys(io.sockets.adapter.rooms[roomCode].sockets).forEach(socket => {
      sockets.push(socket);
    });
  }

  return sockets;
}

/**
 * Zwraca wszystkich graczy aktualnie po≈ÇƒÖczonych z pokojem.
 */
function getPlayersInRoom(roomCode) {
  return rooms[roomCode] ? rooms[roomCode].players : [];
}

/**
 * Rozdaj okre≈õlonƒÖ liczbƒô kart graczowi.
 */
function dealCardsToPlayer(player, numberOfCards = 1) {
  const deck = rooms[player.roomCode].deck;

  for (let i = 0; i < numberOfCards; i++) {
    const card = deck.drawPile.shift();
    if (card) {
      player.addCardToHand(card);
      io.to(player.id).emit('add card to hand', card);
      io.in(player.roomCode).emit('update hand count', player, player.hand.length);
    }
  }

  if (deck.drawPile.length === 0) {
    deck.shuffleDeck();
    io.in(player.roomCode).emit('shuffle deck');
  }
}

/**
 * Sprawd≈∫, czy karta mo≈ºe zostaƒá zagrana, w przeciwnym razie zwr√≥ƒá false.
 */
function checkCardPlayable(card, currentCardInPlay, player) {
  const isPlayable =
    card.suit == currentCardInPlay.suit ||
    card.value == currentCardInPlay.value ||
    card.value == 'q' ||
    (card.value == '2' && currentCardInPlay.value == '2') ||
    (card.value == '3' && currentCardInPlay.value == '3') ||
    (card.value == '4' && currentCardInPlay.value == '4') ||
    (card.value == 'j') ||
    (card.value == 'k' && (currentCardInPlay.value == 'k' || (currentCardInPlay.value == 'a' && (currentCardInPlay.suit == 'hearts' || currentCardInPlay.suit == 'spades')))) ||
    (card.value == 'a');

  return isPlayable;
}
